\section{Application Security Basics}

\subsection{HTTP Basics}

HTTP ist \textbf{Zustandslos}: Der Client sendet eine Anfrage (\textbf{Request}) an den Server, welcher ihn verarbeitet und anschliessend das Resultat als Antwort (\textbf{Response}) zurücksendet.\\

\begin{figure}[H]
	\centering
	\includegraphics[width=0.38\textwidth]{./img/http-head}
	\caption{HTTP Header}
\end{figure}

Zwischen HTTP GET und POST gibt es einen wesentlichen Unterschied. Da der Server die URI in der Regel mitloggt, werden auch die \textbf{Parameter des GET-Request mitgeloggt}. Beim POST-Request geschieht dies nicht, da sich die Parameter anstatt in der URI im Body befinden. Dies ist auch bei Proxies zu beachten. Eine \textbf{Response} ist beinahe Identisch zum Request. Die erste Zeile enthält nun das Protokoll, Statuscode und Statusbeschreibung (HTTP/1.1 200 OK).

\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{./img/http-full-request}
	\caption{Beispielrequests für GET und POST}
\end{figure}

\begin{table}[H]
	\begin{tabularx}{\textwidth}{l|X}
		\textbf{HTTP Methode} & \textbf{Verwendung}\\ \hline
		GET		& normale verwendung *\\ \hline
		POST	& übermittlung von Daten (Login, Formulare) *\\ \hline
		HEAD	& Suchmaschinen (Head of page) *\\ \hline
		PUT		& Upload von Dateien (webdav, RESTful)\\ \hline
		DELETE	& Löschen von Dateien (webdav, RESTful)\\ \hline
		OPTIONS	& Auflistung verfügbarer Methoden auf Server\\ \hline
		TRACE	& Debugging in Webserver\\ \hline
	\end{tabularx}
	\caption{Übliche HTTP Methoden (* meist verwendet)}
\end{table}


\begin{table}[H]
	\begin{tabularx}{\textwidth}{l|p{100pt}|X}
		\textbf{Statuscode} & \textbf{Nachricht} & \textbf{Bedeutung}\\ \hline
		\multicolumn{3}{c}{2xx - Erfolgreich} \\ \hline
		200 & OK & Anfrage erfolgreich bearbeitet, Ergebnis in der Antwort enthalten. \\ \hline
		\multicolumn{3}{c}{3xx - Umleitung} \\ \hline
		301 & Moved Permanently & Header "'Location: http://other-site/"' \\ \hline
		302 & Moved Temporarily & Header "'Location: http://other-site/"'; Alternativ 303 oder 307 möglich \\ \hline
		\multicolumn{3}{c}{4xx - Clientfehler} \\ \hline
		400 & Bad Request & Anfrage war fehlerhaft aufgebaut \\ \hline
		401 & Unauthorized & Authentifizierung nötig \\ \hline
		403 & Forbidden & Mangelnde Berechtigung des Clients \\ \hline
		404 & Not Found & Angeforderte Ressource nicht gefunden \\ \hline
		405 & Method Not Allowed & \\ \hline
		408 & Request Timeout & \\ \hline
		\multicolumn{3}{c}{5xx - Serverfehler} \\ \hline
		500 & Internal Server Error & Allgemeiner Serverfehler \\ \hline
		501 & Not Implemented & Funktionalität wird vom Server nicht bereitgestellt \\ \hline
		502 & Bad Gateway & Proxy hat ungültige Antwort erhalten \\ \hline
		503 & Service Unavailable & Service steht temporär nicht zur verfügung \\ \hline
	\end{tabularx}
	\caption{Übliche HTTP Statuscodes,   \href{https://de.wikipedia.org/wiki/HTTP-Statuscode}{Ausführliche Liste auf Wikipedia}}
\end{table}

\subsection{Redirect after succesful login}
Unter diesem Namen verbirgt sich ein Pattern, um die "'\textbf{Back Button Relogin Vulnerability}"' zu adressieren. Ohne Anwendung dieses Patterns besteht die Möglichkeit, dass nach mehrmaligem Klick auf Zurück die eingegebenen Logindaten erneut an den Server übertragen werden. Bei Fehlschlag des Logins kann mittels eines gewöhnlichen \textit{200 OK} um eine erneute Eingabe gebeten werden.

\begin{figure}[H]
	\includegraphics[width=\textwidth]{./img/PostRedirectGet_DoubleSubmitSolution}
	\caption{Redirect after succesful login}
\end{figure}

Es gibt dabei mehrere Varianten für den Redirect:
\begin{easylist}
	& Type 1 (302 Moved Temporarily)
	&& HTTP Response Status 302
	&& HTTP Response Header "'Location: http://other-site/"'
	& Type 2 (200 OK)
	&& HTTP Response Status 200
	&& HTTP Response Header "'Refresh: 0; URL=http://other-site/"'
	& Type 3 (200 OK)
	&& HTTP Response Page
	&& Meta-Tag "'Refresh"'
	& Type 4 (Javascript)
	&& Client-Seitiger Code (z.B. "'document.location=\ldots"')
\end{easylist}

\subsection{HTTP Session Management}
Serverseitig wird eine Speicherstruktur erstellt, um Session-Daten zu speichern. Der Client erhält ein Schlüssel zu dieser Struktur, auch bekannt als \textit{SessionId}.\\
Bei jeder Anfrage des Clients an den Server muss dieser die \textit{SessionId} mitgeben, damit der Server auf die Daten der Session zugreifen kann. Dazu gibt es mehrere Varianten, wo sich die SessionId befindet (\textbf{Session Locations}):
\begin{easylist}[itemize]
	& URI
	&& Sichtbar in Logs
	&& Problematisch beim Caching
	& Request Header
	&& Cookie, NTLM, BasicAuth
	& Body
	&& Als Hidden Field
	&& Kaum verbreitet
\end{easylist}

\subsection{Cookies}

\begin{verbatim}
Set-Cookie: PREF=ID=2744d38c32b2ec68:LD=de:TM=1094031009
expires=Sun, 17-Jan-2038 19:14:07 GMT; path=/; domain=.google.ch
\end{verbatim}

\begin{figure}[H]
	\centering
	\includegraphics[width=0.6\textwidth]{./img/cookie-creation}
	\caption{Cookie erzeugung über HTTP Request Header}
\end{figure}

\subsubsection{Cookie Attribute}

\begin{easylist}[itemize]
	& \textbf{Name=Content} (Key, value pair)
	&& Name: Cookie Name
	&& Content: Cookie Value
	&& Beispiel: jsessionid=klrezbxur234kls
	& \textbf{Domain}
	&& Ort wohin das Cookie gesendet werden kann.
	&& Default: Cookie wird nur an den Server gesendet, von dem es stammt.
	& \textbf{Path}
	&& URL-Path wohin das Cookie gesendet werden kann.
	&& Default: Cookie wird nur an den Pfad gesendet, von dem es stammt.
	& \textbf{Secure}
	&& Cookie wird nur über HTTPS übermittelt.
	&& Default: insecure
	& \textbf{Expire}
	&& Gültigkeit des Cookies.
	&& Default: wird nicht persistiert, nur Browsersession.
	& \textbf{HttpOnly}
	&& Cookie kann nicht von JavaScript verwendet werden.
	&& Default: nicht vorhanden, JavaScript kann mit document.cookie darauf zugreifen.
\end{easylist}

Wann ein Cookie \textbf{an den Server gesendet} wird, ist abhängig von mehreren Attributen: Domain, Path, Secure und Expire.\\
Das HttpOnly Attribut bietet ein Schutz gegenüber XSS, wobei es dem JavaScript, welches eingeschleust wurde, verhindert wird, auf das Cookie zuzugreifen.

\subsubsection{SSL Session ID}
Mithilfe der \textit{SSL Session ID} können SSL-Session weiter verwendet werden, ohne einen erneuten Handshake durchzuführen. Ähnlich wie bei Cookies werden diese zu beginn der Anfrage an den Server übermittelt, welcher den zur ID passenden symmetrischen Schlüssel besitzt.//
Der gesamte Payload des SSL-Pakets ist verschlüsselt, man sieht also weder die URL noch andere Inhalte des HTTP-Paket.

\todo[inline]{Same Origin Policy}
\todo[inline]{CORS}